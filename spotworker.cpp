/*
 * (C) Copyright 2009 Pål Driveklepp
 *
 * Written by: Pål Driveklepp <jalla2000@gmail.com>
 *
 * See file CREDITS for list of people who contributed to this
 * project.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include <libgen.h>
#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>

#include <QObject>
#include <QTimer>
#include <QFile>
#include <QMessageBox>
#include <QIODevice>
#include <QTextStream>
#include <QMessageBox>

// The one and only entrypoint to the libspotify API
#include <spotify/api.h>

#include "spotworker.hpp"
#include "alsaworker.hpp"
#include "soundsaver.hpp"

#define DEBUGLEVEL 0
#define DEBUG if(DEBUGLEVEL)

/* --- Data --- */
/// The application key is specific to each project, and allows Spotify
/// to produce statistics on how our service is used.
extern const uint8_t g_appkey[];
/// The size of the application key.
extern const size_t g_appkey_size;

//callback functions for libspotify
extern "C" void metadata_updated(sp_session *session);
extern "C" void session_ready(sp_session *session);
extern "C" void session_terminated(void);

extern "C" void connection_error(sp_session *session, sp_error error);
extern "C" void logged_in(sp_session *session, sp_error error);
extern "C" void logged_out(sp_session *session);
extern "C" void notify_main_thread(sp_session *session);
extern "C" void log_message(sp_session *session, const char *data);
extern "C" void loop(sp_session *session);
extern "C" void sigIgn(int signo);


static sp_session_callbacks g_callbacks = {
    &logged_in,
    &logged_out,
    &metadata_updated,
    &connection_error,
    NULL,
    &notify_main_thread,
    &music_delivery,
    &play_token_lost,
    &log_message,
    NULL
};

//The playlist container callbacks

static sp_playlistcontainer_callbacks pc_callbacks = {
	&playlist_added,
	&playlist_removed,
	&playlist_moved,
	&container_loaded
};

//The callbacks we are interested in for individual playlists.
/*
void(* 	tracks_added )(sp_playlist *pl, sp_track *const *tracks, int num_tracks, int position, void *userdata)
void(* 	tracks_removed )(sp_playlist *pl, const int *tracks, int num_tracks, void *userdata)
void(* 	tracks_moved )(sp_playlist *pl, const int *tracks, int num_tracks, int new_position, void *userdata)
void(* 	playlist_renamed )(sp_playlist *pl, void *userdata)
void(* 	playlist_state_changed )(sp_playlist *pl, void *userdata)
void(* 	playlist_update_in_progress )(sp_playlist *pl, bool done, void *userdata)
void(* 	playlist_metadata_updated )(sp_playlist *pl, void *userdata)
 */
static sp_playlist_callbacks pl_callbacks = {
    &tracks_added,
    &tracks_removed,
    &tracks_moved,
    &playlist_renamed,
    NULL,
    NULL,
    NULL
};

bool SpotWorker::instanceFlag_ = false;
SpotWorker* SpotWorker::workerInstance_ = NULL;

SpotWorker* SpotWorker::getInstance()
{
    if (!instanceFlag_)
    {
        workerInstance_ = new SpotWorker();
        instanceFlag_ = true;
        return workerInstance_;
    }
    else
    {
        return workerInstance_;
    }
}

SpotWorker::SpotWorker(QObject *parent)
    : QObject(parent)
{

    totalFrames_ = 0;
    frameCounter_ = -1;
    //playing = false;

    DEBUG printf("SpotWorker started\n");
}

int SpotWorker::start(QString username, QString password)
{
    sp_session_config config;
    sp_error error;

    //signal(SIGIO, SIG_IGN);
    //signal(SIGIO, &SpotWorker::sigIgn);

    // Always do this. It allows libspotify to check for
    // header/library inconsistencies.
    config.api_version = SPOTIFY_API_VERSION;

    // The path of the directory to store the cache. This must be specified.
    // Please read the documentation on preferred values.
    config.cache_location = "tmp";

    // The path of the directory to store the settings. This must be specified.
    // Please read the documentation on preferred values.
    config.settings_location = "tmp";

    // The key of the application. They are generated by Spotify,
    // and are specific to each application using libspotify.
    config.application_key = g_appkey;
    config.application_key_size = g_appkey_size;

    // This identifies the application using some
    // free-text string [1, 255] characters.
    config.user_agent = "spotify-session-example";

    // Register the callbacks.
    config.callbacks = &g_callbacks;

    error = sp_session_init(&config, &currentSession);

    if (SP_ERROR_OK != error) {
	fprintf(stderr, "failed to create session: %s\n",
		sp_error_message(error));
    }

    // Login using the credentials given on the command line.
    //printf("Logging in...\n");
    error = sp_session_login(currentSession, 
			     username.toUtf8().data(), 
			     password.toUtf8().data());

    DEBUG printf("sp_session_login returned %d\n", error);

    if (SP_ERROR_OK != error) {
	fprintf(stderr, "failed to login: %s\n",
		sp_error_message(error));
    }

    eventTimer = new QTimer();
    connect(eventTimer, SIGNAL(timeout()), SLOT(processEvents()) );
    eventTimer->start( 3000 );
    watchDog_ = new QTimer();
    connect(watchDog_, SIGNAL(timeout()), SLOT(streamingStopped()) );

    // TODO: find out what these two lines do, 
    // and why they are commented out
    //loop(session);
    //session_terminated();

    soundSaver_ = new SoundSaver();
    alsaWorker_ = new AlsaWorker();
    DEBUG printf("Spotworker started with soundSaver and alsaWorker constructed\n");

    return 0; //TODO: return something else when stuff fail.

}

void SpotWorker::performSearch(QString query)
{
    const char *needle = query.toUtf8().data();
    DEBUG printf("Requesting search. Query: %s", needle);
    const int track_offset = 0;
    const int track_count = 100;
    const int album_offset = 0;
    const int album_count = 100;
    const int artist_offset = 0;
    const int artist_count = 100;
    g_search = sp_search_create(currentSession,
				needle,
				track_offset,
				track_count,
				album_offset,
				album_count,
				artist_offset,
				artist_count,
				search_complete,
				NULL);

    if (!g_search) {
	fprintf(stderr, "Clay Davis says: Sheeeet! Failed to start search!\n");
    }
}

//void SpotWorker::loadPlayer(sp_session *session, sp_track *track)
void SpotWorker::loadPlayer(sp_track *track, bool rip, SoundSaver::FileType type)
{
    totalFrames_ = sp_track_duration(track)*44;
    alsaWorker_->audioFifoFlush();
    frameCounter_ = 0;
    //printf("Splitting output files...\n");

    closeFile();
    if(rip){
	saveFile(track, type);
	DEBUG printf("Debug: bool received: true\n");
    }
    else
	DEBUG printf("Debug: bool received: false\n");
    //printf("Loading the player...4real\n");
    sp_session_player_load(currentSession, track);
}
void SpotWorker::playPlayer(bool play)
{
    sp_error err = sp_session_player_play(currentSession, play);
    alsaWorker_->pause(!play);
    err = err;
}
void SpotWorker::seekPlayer(int offset)
{
    sp_error err = sp_session_player_seek(currentSession, offset);
    err = err;
}
bool SpotWorker::isPlaying()
{
    return alsaWorker_->isPlaying();
}
bool SpotWorker::isStreaming()
{
    return this->streaming_;
}


void SpotWorker::processEvents()
{
    //printf("processEvents called!\n");
    int timeout = 1000;
    sp_session_process_events(currentSession, &timeout);
    eventTimer->setInterval(timeout);
}


/* ------------------------  BEGIN SESSION CALLBACKS  ---------------------- */
/**
 * This callback is called when the user was logged in, but the connection to
 * Spotify was dropped for some reason.
 *
 * @sa sp_session_callbacks#connection_error
 */
extern "C" void connection_error(sp_session *session, sp_error error)
{
    fprintf(stderr, "connection to Spotify failed: %s\n", sp_error_message(error));
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitConnectionErrorSignal(session, error);
}

//Emit QT-signal for spotify callback
void SpotWorker::emitConnectionErrorSignal(sp_session *session, sp_error error)
{
    DEBUG printf("Emitting signal connectionError\n");
    emit connectionError(session, error);
}


/**
 * This callback is called when an attempt to login has succeeded or failed.
 *
 * @sa sp_session_callbacks#logged_in
 */
extern "C" void logged_in(sp_session *session, sp_error error)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitLoggedInSignal(session, error);

    if (SP_ERROR_OK == error) {
	// Let us print the nice message...
	sp_user *me = sp_session_user(session);
	const char *my_name = (sp_user_is_loaded(me) ?
			       sp_user_display_name(me) :
			       sp_user_canonical_name(me));
	DEBUG printf("Logged in to Spotify as user %s\n", my_name);
	session_ready(session);
    }
}

//Emit QT-signal for spotify callback
void SpotWorker::emitLoggedInSignal(sp_session *session, sp_error error)
{
    if (SP_ERROR_OK != error) {
	fprintf(stderr, "SpotWorker: Login failed: %s\n",
		sp_error_message(error));
    }
    else{

	emit loggedIn(session, error);

	sp_playlistcontainer *playlists = sp_session_playlistcontainer(session);
	void * userdata = NULL;
	sp_playlistcontainer_add_callbacks(playlists,
					   &pc_callbacks,
					   userdata);

	int i;
	int listCount = sp_playlistcontainer_num_playlists(playlists);
	printf("%d playlists discovered\n", sp_playlistcontainer_num_playlists(playlists));

	if(listCount > 0)
	    emit playlistsDiscovered(playlists);

	for (i = 0; i < sp_playlistcontainer_num_playlists(playlists); ++i) {
	    sp_playlist *pl = sp_playlistcontainer_playlist(playlists, i);

	    //TODO: register callback
	    //sp_playlist_add_callbacks(pl, &pl_callbacks, NULL);

	    //if (!strcasecmp(sp_playlist_name(pl), g_listname)) {
	    //    g_jukeboxlist = pl;
	    //    try_jukebox_start();
	    //}
	    DEBUG printf("Playlist found: %s\n", sp_playlist_name(pl));
	}

	/*
	  if (!g_jukeboxlist) {
	  printf("jukebox: No such playlist. Waiting for one to pop up...\n");
	  fflush(stdout);
	  }
	*/
    }
}

/**
 * This callback is called when the session has logged out of Spotify.
 *
 * @sa sp_session_callbacks#logged_out
 */
extern "C" void logged_out(sp_session *session)
{
    //if (g_exit_code< 0)
    //	g_exit_code = 0;
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitLoggedOutSignal(session);   
    DEBUG printf("Logged out of Spotify...\n");
}

//Emit QT-signal for spotify callback
void SpotWorker::emitLoggedOutSignal(sp_session *session)
{
    DEBUG printf("Emitting signal loggedOut\n");
    emit loggedOut(session);
}


/**
 * This callback is called from an internal libspotify thread to ask us to
 * reiterate the main loop.
 *
 * The most straight forward way to do this is using Unix signals. We use
 * SIGIO. signal(7) in Linux says "I/O now possible" which sounds reasonable.
 *
 * @sa sp_session_callbacks#notify_main_thread
 */
extern "C" void notify_main_thread(sp_session *)
{
    //pthread_kill(g_main_thread, SIGIO);
    //printf("notify_main_thred called!\n");
}

extern "C" int music_delivery(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames)
{
    SpotWorker *sw = SpotWorker::getInstance();
    return sw->emitMusicDeliverySignal(session, format, frames, num_frames);
}
//Emit QT-signal for spotify callback
int SpotWorker::emitMusicDeliverySignal(sp_session *session, const sp_audioformat *format, const void *frames, int num_frames)
{
    int framesEaten = alsaWorker_->musicDelivery(session, format, frames, num_frames);
    frameCounter_ += framesEaten;
    //check if the song is buffered completely

    /* Check if end of song is reached
     * If the samplerate is 44.1kHz, we should get about 44100 frames per second.
     * This is approximately 44.1 samples per millisecond. If the difference
     * totalFrames-frameCouner < threshold, the song is probably buffered.
     * In addition, a timer is used for extra safety.
     */
    //printf("Frames left: %d", totalFrames - frameCounter);
    if(totalFrames_ - frameCounter_ > 100){
	watchDog_->start(1000);
    }

    soundSaver_->saveSound(frames, framesEaten);
    return framesEaten;
}

extern "C" void play_token_lost(sp_session *session)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitPlayTokenLostSignal(session);
    DEBUG printf("Emitting signal playTokenLost\n");
}
//Emit QT-signal for spotify callback
void SpotWorker::emitPlayTokenLostSignal(sp_session *session)
{
    emit playTokenLost(session);
}

/**
 * This callback is called for log messages.
 *
 * @sa sp_session_callbacks#log_message
 */
extern "C" void log_message(sp_session * /*session*/, const char *data)
{
	fprintf(stderr, "log_message: %s\n", data);
}



/**
 * A dummy function to ignore SIGIO.
 */
extern "C" void sigIgn(int signo)
{
    DEBUG printf("sigIgn: %d\n", signo);
}




/**
 * Callback called when libspotify has new metadata available
 *
 * Not used in this example (but available to be able to reuse the session.c file
 * for other examples.)
 */
extern "C" void metadata_updated(sp_session *session)
{
    //dummy to avoid compile warning
    sp_session *jalla = session;
    jalla = jalla;
}

/**
 * Callback called when the session has successfully logged in
 *
 * This is where we start two browse requests; one artist and one album. They
 * will eventually call the album_complete() and artist_complete() callbacks.
 *
 * This
 */
extern "C" void session_ready(sp_session *session)
{
    DEBUG printf("Session ready called!\n");

    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitSessionReadySignal(session);
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSessionReadySignal(sp_session *session)
{
    //printf("Emitting signal sessionReady\n");
    emit sessionReady(session);
}

/**
 * Callback for libspotify
 *
 * @param browse    The browse result object that is now done
 * @param userdata  The opaque pointer given to sp_artistbrowse_create()
 */
extern "C" void search_complete(sp_search *search, void *userdata)
{
    //dummy to avoid compile warning
    void *jalla = userdata;
    jalla = jalla;
    
    SpotWorker *sw = SpotWorker::getInstance();

    //TODO: move these checks to signal receiver
    //TODO: why is *userdata not passed to signal?
    if (search && SP_ERROR_OK == sp_search_error(search)){
	//sw->print_search(search);
	sw->emitSearchCompleteSignal(search);
    }
    else{
	fprintf(stderr, "Failed to search: %s\n", sp_error_message(sp_search_error(search)));
	sw->emitSearchCompleteSignal(NULL);
    }
    //sp_search_release(sw->g_search);

    //terminate();
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSearchCompleteSignal(sp_search *search)
{
    //printf("Emitting signal searchComplete\n");
    emit searchComplete(search);
}

/**
 * Callback called when the session has been terminated.
 */
extern "C" void session_terminated(void)
{
    SpotWorker *sw = SpotWorker::getInstance();
    sw->emitSessionTerminatedSignal();
}

//Emit QT-signal for spotify callback
void SpotWorker::emitSessionTerminatedSignal(void)
{
    DEBUG printf("Emitting signal sessionTerminated\n");
    emit sessionTerminated();
}


/* --------------------  PLAYLIST CONTAINER CALLBACKS  --------------------- */
/**
 * Callback from libspotify, telling us a playlist was added to the playlist container.
 *
 * We add our playlist callbacks to the newly added playlist.
 *
 * @param  pc            The playlist container handle
 * @param  pl            The playlist handle
 * @param  position      Index of the added playlist
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_added(sp_playlistcontainer */*pc*/, sp_playlist *pl,
			       int position, void * /*userdata*/)
{
    DEBUG printf("SpotWorker: playlist_added: (position: %d, name:%s)\n",
		 position,
		 sp_playlist_name(pl));
    sp_playlist_add_callbacks(pl, &pl_callbacks, NULL);

    /*    if (!strcasecmp(sp_playlist_name(pl), g_listname)) {
	g_jukeboxlist = pl;
    }
    */
}

/**
 * Callback from libspotify, telling us a playlist was removed from the playlist container.
 *
 * This is the place to remove our playlist callbacks.
 *
 * @param  pc            The playlist container handle
 * @param  pl            The playlist handle
 * @param  position      Index of the removed playlist
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_removed(sp_playlistcontainer * /*pc*/, sp_playlist *pl,
				 int position, void * /*userdata*/)
{
    printf("SpotWorker: playlist_removed (name: %s, position:%d)\n",
	   sp_playlist_name(pl),
	   position);
    sp_playlist_remove_callbacks(pl, &pl_callbacks, NULL);
}

extern "C" void playlist_moved(sp_playlistcontainer * /*pc*/,
			       sp_playlist *playlist,
			       int position,
			       int new_position,
			       void * /*userdata*/)
{
    DEBUG printf("SpotWorker: playlist_moved (name: %s, pos:before/after=(%d/%d))\n",
		 sp_playlist_name(playlist),
		 position,
		 new_position);
}

/**
 * Callback from libspotify, telling us the rootlist is fully synchronized
 * We just print an informational message
 *
 * @param  pc            The playlist container handle
 * @param  userdata      The opaque pointer
 */
extern "C" void container_loaded(sp_playlistcontainer *pc, void * /*userdata*/)
{
    DEBUG printf("SpotWorker: container_loaded (%d playlists)\n",
		 sp_playlistcontainer_num_playlists(pc));
}

/* --------------------------  PLAYLIST CALLBACKS  ------------------------- */
/**
 * Callback from libspotify, saying that a track has been added to a playlist.
 *
 * @param  pl          The playlist handle
 * @param  tracks      An array of track handles
 * @param  num_tracks  The number of tracks in the \c tracks array
 * @param  position    Where the tracks were inserted
 * @param  userdata    The opaque pointer
 */
extern "C" void tracks_added(sp_playlist * /*pl*/,
			     sp_track *const * /*tracks*/,
			     int num_tracks,
			     int /*position*/,
			     void * /*userdata*/)
{
    /*
	if (pl != g_jukeboxlist)
		return;
    */
    DEBUG printf("%d tracks were added to a playlist\n", num_tracks);
    fflush(stdout);
}



/**
 * Callback from libspotify, saying that a track has been added to a playlist.
 *
 * @param  pl          The playlist handle
 * @param  tracks      An array of track indices
 * @param  num_tracks  The number of tracks in the \c tracks array
 * @param  userdata    The opaque pointer
 */
extern "C" void tracks_removed(sp_playlist * /*pl*/, const int * /*tracks*/,
			       int num_tracks, void * /*userdata*/)
{
    //int i, k = 0;

    /*
    if (pl != g_jukeboxlist)
        return;

    for (i = 0; i < num_tracks; ++i)
        if (tracks[i] < g_track_index)
            ++k;

    g_track_index -= k;
    */
    DEBUG printf("%d tracks were removed from a playlist\n", num_tracks);
    fflush(stdout);
}

/**
 * Callback from libspotify, telling when tracks have been moved around in a playlist.
 *
 * @param  pl            The playlist handle
 * @param  tracks        An array of track indices
 * @param  num_tracks    The number of tracks in the \c tracks array
 * @param  new_position  To where the tracks were moved
 * @param  userdata      The opaque pointer
 */
extern "C" void tracks_moved(sp_playlist * /*pl*/,
			     const int * /*tracks*/,
			     int num_tracks,
			     int /*new_position*/,
			     void * /*userdata*/)
{
    //TODO: Use more function parameters
    /*
	if (pl != g_jukeboxlist)
		return;
    */
	DEBUG printf("%d tracks were moved around in a playlist\n", num_tracks);
	fflush(stdout);
}

/**
 * Callback from libspotify. Something renamed the playlist.
 *
 * @param  pl            The playlist handle
 * @param  userdata      The opaque pointer
 */
extern "C" void playlist_renamed(sp_playlist *pl, void * /*userdata*/)
{
	const char *name = sp_playlist_name(pl);

	/*
	if (!strcasecmp(name, g_listname)) {
	g_jukeboxlist = pl;
	g_track_index = 0;
	try_jukebox_start();
	} else if (g_jukeboxlist == pl) {
	*/
	DEBUG printf("Current playlist renamed to \"%s\".\n", name);
	/*
	  g_jukeboxlist = NULL;
	  g_currenttrack = NULL;
	  sp_session_player_unload(g_sess);
	  }
	*/
}



/**
 * Print the given track title together with some trivial metadata
 *
 * @param  track   The track object
 */

/*
void SpotWorker::print_track(sp_track *track)
{
	int duration = sp_track_duration(track);

	printf("  Track \"%s\" [%d:%02d] has %d artist(s), %d%% popularity\n",
		sp_track_name(track),
		duration / 60000,
		(duration / 1000) / 60,
		sp_track_num_artists(track),
		sp_track_popularity(track));
}
*/

/**
 * Print the given album metadata
 *
 * @param  album  The album object
 */

/*
void SpotWorker::print_album(sp_album *album)
{
	printf("  Album \"%s\" (%d)\n",
	       sp_album_name(album),
	       sp_album_year(album));
}
*/

/**
 * Print the given artist metadata
 *
 * @param  artist  The artist object
 */
/*
void SpotWorker::print_artist(sp_artist *artist)
{
	printf("  Artist \"%s\"\n", sp_artist_name(artist));
}
*/

/**
 * Print the given search result with as much information as possible
 *
 * @param  search   The search result
 */
void SpotWorker::print_search(sp_search *search)
{
    DEBUG {
	printf("Query          : %s\n", sp_search_query(search));
	printf("Did you mean   : %s\n", sp_search_did_you_mean(search));
	printf("Tracks in total: %d\n", sp_search_total_tracks(search));
	puts("");
    }
    /*
      int i;

      for (i = 0; i < sp_search_num_tracks(search) && i < 10; ++i)
      print_track(sp_search_track(search, i));

      puts("");

      for (i = 0; i < sp_search_num_albums(search) && i < 10; ++i)
          print_album(sp_search_album(search, i));

      puts("");

      for (i = 0; i < sp_search_num_artists(search) && i < 10; ++i)
          print_artist(sp_search_artist(search, i));

      puts("");
    */
}

void SpotWorker::streamingStopped()
{
    watchDog_->stop();
    DEBUG printf("Streamstop signal received\n");
    soundSaver_->close();
    streaming_ = false;
}

void SpotWorker::playbackStopped()
{
    //this->playing = false;
}

void SpotWorker::saveFile(sp_track *track, SoundSaver::FileType nextFile)
{
    /* Close previous file
     * This should be done by both the soundsaver and the spotworker
     * so this code is probably triple redundant. Wear seatbelts!
     */
    if(soundSaver_){
	DEBUG printf("Closing open file...\n");
	soundSaver_->close();
	DEBUG printf("Closed!\n");
    }

    //start a new file
    DEBUG printf("Extracting filename from track...\n");
    sp_artist *tartist = sp_track_artist(track, 0);
    const char *artistName = sp_artist_name(tartist);
    const char *trackName = sp_track_name(track);
    QString fileName("./");
    fileName += QString(QString().fromUtf8(artistName)) + 
	" - " + QString(QString().fromUtf8(trackName));
    DEBUG printf("Making new soundsaver...\n");
    soundSaver_->open(fileName.toUtf8().data(), nextFile);
    DEBUG printf("Soundsaver made. returning...\n");
}

void SpotWorker::closeFile()
{
    //close previous file
    if(soundSaver_){
	DEBUG printf("Closing open file...");
	soundSaver_->close();
	DEBUG printf("Closed!\n");
    }
}
 
 /*
   void SpotWorker::ResetCounter()
   {
   frameCounter = 0;
   }
 */

int SpotWorker::getProgress()
{
    return frameCounter_/44; //%TODO: dirty constant
}

int SpotWorker::getSongLength()
{
    return totalFrames_/44;
}


void SpotWorker::startServer()
{
    tcpServer_ = new QTcpServer(this);

    if (!tcpServer_->listen(QHostAddress::Any, 2718)) {
	/*	QMessageBox::warning(this, tr("Error"),
			      tr("Failed to start server: %1.")
			     .arg(anyWho->errorString()));
	*/
	DEBUG printf("SpotWorker::startServer(): Epic error!\n");
	return;
    }
    DEBUG printf("TCP server started!\n");
    connect(tcpServer_, SIGNAL(newConnection()), this, SLOT(netConnection()) );
}

void SpotWorker::netConnection()
{
    DEBUG printf("Connection initiated!\n");
    serverData_.state = 0;
    serverData_.xfered = 0;
    clientConnection_ = tcpServer_->nextPendingConnection();
    connect(clientConnection_, SIGNAL(disconnected()),
	    clientConnection_, SLOT(deleteLater()));
    connect(clientConnection_, SIGNAL(readyRead()),
	    this, SLOT(rxDataReady()) );
}

void SpotWorker::rxDataReady()
{
    qint64 amount = this->clientConnection_->bytesAvailable();
    qint64 handled = 0;

    DEBUG printf("Incoming data! Amount: %lld\n", amount);

    while (handled < amount){

	if (serverData_.state==0 && amount>=4){
	    char buf[4];
	    qint64 received = clientConnection_->read(buf, 4);
	    handled += received;
	    for(int i = 0; i < 4; i++)
		((char *)&serverData_.type)[i] = buf[3-i];
	    DEBUG printf("Packet received. Type: %d\n", serverData_.type);
	    serverData_.state = 1;
	}

	if (serverData_.state==1 && amount>=4){
	    char buf[4];
	    qint64 received = clientConnection_->read(buf, 4);
	    handled += received;
	    for(int i = 0; i < 4; i++)
		((char *)&serverData_.length)[i] = buf[3-i];
	    DEBUG printf("Packet size: %d\n", serverData_.length);
	    if(serverData_.length > MAX_PACKET_SIZE)
		DEBUG printf("Length of packet is crazy. Client is a bastard!");
	    serverData_.state = 2;
	}
	if (serverData_.state == 2){
	    if(serverData_.xfered==serverData_.length){
		DEBUG printf("Complete packet received\n");
		parsePacket();
	    }
	    else {
		qint64 received = clientConnection_->read((char *)&serverData_.data, serverData_.length-serverData_.xfered);
		handled += received;
		//printf("Packet received. Type: %d\n", serverData.type);
		serverData_.xfered += received;
		printf("%lld bytes added to buffer\n", received);
	    }
	}
    }
}

void SpotWorker::parsePacket()
{
    DEBUG {
	printf("packet type: %d\n", serverData_.type);
	printf("Playstop: %d\n", PLAYSTOP);
	printf("Nextblock: %d\n", NEXTBLOCK);
    }

    switch(serverData_.type){
    case PLAYSTOP:
	playPlayer(!isPlaying());
	break;
    case NEXTBLOCK:
	DEBUG printf("TODO: send block of audio data\n");
	break;
    default:
	DEBUG printf("Package had illegal type. Dropping.\n");
    }

    serverData_.state = 0;
    serverData_.xfered = 0;
}
